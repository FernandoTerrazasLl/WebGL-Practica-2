<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Cosmografía Fractal (PCC)</title>
    
    <style>
        /* Configura el cuerpo para que no tenga márgenes y oculte barras de desplazamiento (Fullscreen) */
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        /* Estilo para el cuadro de información flotante en la esquina */
        #info {
            position: absolute;     /* Posición libre sobre el canvas */
            top: 10px; left: 10px;  /* Ubicación esquina superior izquierda */
            color: white;           /* Texto blanco */
            font-family: sans-serif; 
            background: rgba(0,0,0,0.7); /* Fondo negro semitransparente para leer mejor */
            padding: 10px; 
            border-radius: 5px;     /* Bordes redondeados */
            pointer-events: none;   /* Permite hacer clic "a través" del cuadro (no bloquea el mouse) */
            user-select: none;      /* Evita que el usuario seleccione el texto accidentalmente */
        }
    </style>
    
    <script src="MVnew.js"></script>
    <script src="initShaders.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script id="vertex-shader" type="x-shader/x-vertex">
    #version 300 es
    
    // --- DATOS QUE RECIBIMOS PARA CADA ESTRELLA ---
    in vec3 a_posUniform;  // Posición si está en modo ordenado (cuadrícula)
    in vec3 a_posFractal;  // Posición si está en modo agrupado (galaxias)
    in float a_size;       // Tamaño único de esta estrella
    in float a_colorVar;   // Número aleatorio (0 a 1) para variar el color

    // --- CONFIGURACIÓN QUE RECIBIMOS DEL MENÚ ---
    uniform mat4 u_modelViewMatrix;  // Controla hacia dónde miramos y cómo rotamos
    uniform mat4 u_projectionMatrix; // Controla la perspectiva 3D
    uniform float u_mixFactor;       // Valor del slider: 0 = ordenado, 1 = agrupado
    uniform float u_time;            // Tiempo actual para hacer que las cosas se muevan
    uniform float u_speed;           // Qué tan rápido viajamos
    uniform float u_baseSize;        // Multiplicador del tamaño de todas las estrellas

    // --- DATOS QUE ENVIAMOS AL SIGUIENTE PASO (fragment shader) ---
    out float v_opacity;   // Transparencia de esta estrella (para hacer niebla)
    out float v_colorMix;  // El número de color que calculamos aquí

    void main() {
        // 1. MEZCLAR ENTRE MODO ORDENADO Y AGRUPADO
        // Si u_mixFactor es 0: usa a_posUniform (ordenado)
        // Si u_mixFactor es 1: usa a_posFractal (agrupado)
        // Si está en medio: mezcla ambas posiciones
        vec3 mixedPos = mix(a_posUniform, a_posFractal, u_mixFactor);

        // 2. HACER QUE LAS ESTRELLAS SE MUEVAN HACIA NOSOTROS
        // Multiplicamos el tiempo por la velocidad para mover en Z
        // Usamos mod para que cuando pase de 3000, vuelva a -1500 (bucle infinito)
        float zPos = mod(mixedPos.z + (u_time * u_speed), 3000.0) - 1500.0;
        
        // Crear la posición final en 3D combinando X, Y de la mezcla y la Z animada
        vec4 pos = u_modelViewMatrix * vec4(mixedPos.x, mixedPos.y, zPos, 1.0);

        // 3. CALCULAR EL TAMAÑO DE ESTA ESTRELLA EN PANTALLA
        
        // Las cosas lejanas se ven más pequeñas: dividimos 1000 entre la distancia
        // pos.z es negativo cuando está delante de nosotros, por eso usamos -pos.z
        float distScale = 1000.0 / -pos.z;
        
        // Calcular tamaño final: tamaño único × tamaño del menú × efecto de distancia
        // max asegura que nunca sea negativo
        gl_PointSize = max(0.0, a_size * u_baseSize * distScale);

        // 4. CREAR EFECTO DE NIEBLA (las cosas lejanas se ven más transparentes)
        // smoothstep hace una transición suave entre 1500 y 1000
        // Si está más lejos de 1500: transparente (0), si está más cerca de 1000: opaco (1)
        float fog = smoothstep(1500.0, 1000.0, abs(zPos));
        
        // En modo agrupado brillan más (1.0), en modo ordenado un poco menos (0.8)
        v_opacity = fog * mix(0.8, 1.0, u_mixFactor); 
        
        // Pasar el color al siguiente paso
        v_colorMix = a_colorVar;
        
        // Calcular la posición final en pantalla con perspectiva
        gl_Position = u_projectionMatrix * pos;
    }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
    #version 300 es
    // Usar precisión media para que funcione bien en todos los dispositivos
    precision mediump float;

    // Colores que configuramos en el menú
    uniform vec3 u_colorCore; // Color del centro de las estrellas
    uniform vec3 u_colorRim;  // Color del borde de las estrellas
    // Necesitamos alta precisión aquí para que coincida con el vertex shader
    uniform highp float u_mixFactor; 

    // Datos que recibimos del vertex shader
    in float v_opacity;   // Qué tan transparente es esta estrella
    in float v_colorMix;  // Número para variar el color
    
    // Color final que vamos a mostrar en pantalla
    out vec4 outColor;

    void main() {
        // 1. HACER QUE LAS ESTRELLAS SEAN REDONDAS
        // gl_PointCoord nos da la posición dentro del cuadrado del punto (de 0 a 1)
        // Restamos 0.5 para centrar en 0, así podemos medir la distancia al centro
        vec2 coord = gl_PointCoord - vec2(0.5);
        
        // Calcular qué tan lejos estamos del centro
        float dist = length(coord);
        
        // Si estamos más lejos de 0.5, estamos en las esquinas del cuadrado
        // Descartar esos pixeles para que solo quede un círculo
        if (dist > 0.5) discard;

        // 2. CALCULAR EL COLOR DE ESTA ESTRELLA
        // Mezclar entre el color del centro y el borde según el número aleatorio
        vec3 fractalColor = mix(u_colorCore, u_colorRim, v_colorMix);
        
        // Para el modo ordenado, usar un gris claro (todas iguales, sin variedad)
        vec3 uniformColor = vec3(0.9, 0.9, 0.9); 

        // Mezclar entre gris (modo ordenado) y colores variados (modo agrupado)
        // según el valor del slider
        vec3 finalColor = mix(uniformColor, fractalColor, u_mixFactor);

        // 3. HACER QUE EL CENTRO BRILLE MÁS QUE LOS BORDES
        // Invertir la distancia: 1.0 en el centro, 0.0 en el borde
        float alpha = 1.0 - (dist * 2.0);
        // Elevar al cuadrado para que el brillo caiga más suavemente
        alpha = pow(alpha, 2.0); 

        // Crear el color final: RGB del color + Alpha de transparencia
        // Multiplicar alpha por v_opacity para que las estrellas lejanas sean más transparentes
        outColor = vec4(finalColor, alpha * v_opacity);
    }
    </script>
</head>
<body>
    <div id="info">
        <h2>Proyecto Final: Estacionariedad Condicional</h2>
        <p>Visualización: Principio Uniforme vs. Fractal</p>
    </div>
    
    <canvas id="gl-canvas"></canvas>
    
    <script src="Project.js"></script>
</body>
</html>